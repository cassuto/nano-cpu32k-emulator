; OpenPX architecture -*- Scheme -*-
; Copyright (C) 2016 the 1st Middle School in Yongsheng, Lijiang, China.
;***************************************************************************
;
; This program is free software; you can redistribute it and/or modify
; it under the terms of the GNU General Public License as published by
; the Free Software Foundation; either version 3 of the License, or
; (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, see <http://www.gnu.org/licenses/>

(include "simplify.inc")


(define-arch
  (name openpx64k)
  (comment "OpenPX 64k")
  (default-alignment aligned)
  (insn-lsb0? #t)
  (machs openpx64000)
  (isas openpx64k-p32)
)

; Instruction set parameters.
(define-isa
  ; Name of the ISA.
  (name openpx64k-p32)
  ; Base insturction length.  The insns are fixed 32 bits wide.
  (base-insn-bitsize 32)
  )

(define-pmacro OPENPXb-MACHS   openpx64000)
(define-pmacro OPENPXb32-MACHS openpx64000)
(define-pmacro OPENPXb64-MACHS openpx64000)

(define-pmacro OPENPXf-MACHS   openpx64000)
(define-pmacro OPENPXf32-MACHS openpx64000)
(define-pmacro OPENPXf64-MACHS openpx64000)

(if (keep-mach? (openpx64000) )
    (begin
      (define-cpu
        (name openpx64kf)
        (comment "OpenPX 64k CPU family")
        (insn-endian little)
        (data-endian little)
        (word-bitsize 32)
        (file-transform "")
        )

      (define-mach
        (name openpx64000)
        (comment "OpenPX 64000 32-bit CPU")
        (cpu openpx64kf)
        (bfd-name "openpx64k")
        )

      ; OpenPX 64000b - Processor with basis functions
      (define-model
        (name openpx64000b) (comment "OpenPX 64000b model")
        (attrs)
        (mach openpx64000)
        (unit u-exec "Execution Unit" () 1 1 () () () ())
        )
        
      )
    )

;
; Description of hardwave elements
;

;***************************************************************************
; Registers
;***************************************************************************

(define-hardware
  (name h-pc)
  (comment "program counter")
  (attrs PC (MACH OPENPXb-MACHS))
  (type pc UWI)
  (get () (raw-reg h-pc))
  (set (newval) (sequence ()
                 (set (reg h-sys-ppc) (raw-reg h-pc))
                 (set (raw-reg h-pc) newval)
                ))
  )


(define-pmacro REG-INDICES
  ((r0 0)
   (r1 1)
   (r2 2)
   (r3 3)
   (r4 4)
   (r5 5)
   (r6 6)
   (r7 7)
   (r8 8)
   (r9 9)
   (r10 10)
   (r11 11)
   (r12 12)
   (r13 13)
   (r14 14)
   (r15 15)
   (r16 16)
   (r17 17)
   (r18 18)
   (r19 19)
   (r20 20)
   (r21 21)
   (r22 22)
   (r23 23)
   (r24 24)
   (r25 25)
   (r26 26)
   (r27 27)
   (r28 28)
   (r29 29)
   (r30 30)
   (r31 31)
   (va0 1)
   (va1 2)
   (va2 3)
   (va3 4)
   (va4 5)
   (va5 6)
   (rv  7)
   (rvh 8)
   (lnk 29)
   (fp 30)
   (sp 31))
  )

;
; FRS
;
(define-hardware
  (name h-frs)
  (comment "floating point registers (single, virtual)")
  (attrs VIRTUAL (MACH OPENPXf32-MACHS))
  (type register SF (32))
  (indices keyword "" REG-INDICES)
  (get (index) (subword SF (trunc SI (reg h-gpr index)) 0))
  (set (index newval) (set UWI (reg h-gpr index) (zext UWI (subword SI newval 0))))
  )

;
; FRD
;
(define-hardware
  (name h-frd) (comment "floating point registers (double, virtual)")
  (attrs VIRTUAL (MACH OPENPXf64-MACHS))
  (type register DF (32))
  (indices keyword "" REG-INDICES)
  (get (index) (subword DF (trunc DI (reg h-gpr index)) 0))
  (set (index newval) (set UDI (reg h-gpr index) (zext UDI (subword DI newval 0))))
  )

;
; CSMR
;
(define-hardware
  (name h-csmr) (comment "CPU status management registers")
  (attrs VIRTUAL (MACH OPENPXb-MACHS))
  (type register UWI (#x20000))
  (get (index) (c-call UWI "@cpu@_h_csmr_get_raw" index))
  (set (index newval) (c-call VOID "@cpu@_h_csmr_set_raw" index newval))
)

;
;todo! csmr address
;
(define-pmacro csmr-shift 11)
(define-pmacro (csmr-address csmr-entry csmr-index)
  (or (sll UWI (enum UWI (.sym "CSMR-ENTRY-" csmr-entry)) csmr-shift)
      (enum UWI (.sym "CSMR-INDEX-" csmr-entry "-" csmr-index))))

;
; GPR
;
(define-hardware
  (name h-gpr) (comment "general registers")
  (attrs (MACH OPENPXb-MACHS))
  (type register UWI (32))
  (indices keyword "" REG-INDICES)
  (get (index) (reg UWI h-csmr (add index (csmr-address CCFG GPR0))))
  (set (index newval) (set UWI (reg UWI h-csmr (add index (csmr-address CCFG GPR0))) newval))
  )
  

;***************************************************************************
; Exception
;***************************************************************************

;!todo exception codes  
(define-normal-enum
  except-number
  "Exception numbers"
  ()
  EXCEPT-
  (("ERST"          #x01)
   ("EBUS"          #x02)
   ("EINSN"         #x03)
   ("ESYSCALL"      #x04)
   ("EIPF"          #x05)
   ("EDPF"          #x06)
   ("EITLB"         #x07)
   ("EDTLB"         #x08)
   ("EIRQ"          #x09)
   ("EOVERFLOW"     #x0a)
   ("EFPU"          #x0b)
   ("ETRAP"         #x0c)
   ("EDALIGN"       #x0d)
   )
  )

(define-pmacro (raise-exception exnum)
  (c-call VOID "@cpu@_exception" pc exnum))


;***************************************************************************
; CSMR fields
;***************************************************************************

(define-normal-enum
  csmr-groups
  "CPU status management register groups"
  ()
  CSMR-ENTRY-
  (("CR"        #x0)
   ("CSR"       #x1)
   )
  )

(define-pmacro (csmr-reg-info)
  (.splice
   (CR CPUID    #x000 "CPU Identifier Information")
   (CR EX       #x001 "Exception control")
   (CR EB       #x002 "Exception Base address")
   (CR EPC      #x003 "Exception PC")
   (CR ECSR     #x004 "Exception saved CSR")
   (CR DPR      #x005 "Device Present")
   (CR ICC      #x006 "I-Cache control")
   (CR DCC      #x007 "D-Cache control")
   (CR IMMUC    #x008 "I-MMU control")
   (CR DMMUC    #x009 "D-MMU control")
   (CR TRMUC    #x00a "Timer Unit control")
   (CR PICUC    #x00b "PIC Unit control")
   (CR DBGUC    #x00c "Debug Unit control")
   (CR FPUC     #x00d "Floating Processor Unit control")
   (CR PMUC     #x00e "Power Management Unit control")
   (CR PMCUC    #x00f "Performance Counters Unit control")
   
   (.unsplice
    (.map (.pmacro (n) (.splice CR (.sym "GPR" n) (.add n #x400) (.str "General purpose register " n)))
          (.iota #x200)))
          
   (CSR PSR     #x000 "Program Status Register")
   (CSR MSR     #x001 "Mode Status Register")
   (CSR FSR     #x002 "Float Status Register")
   )
  )

(define-normal-enum
  csmr-reg-indices
  "CPU status management register indicies"
  ()
  CSMR-INDEX-
  (.map (.pmacro (args)
                 (.apply (.pmacro (entry index n comment)
                                  ((.sym entry "-" index) n))
                         args)
                 )
        (csmr-reg-info)
        )
  )

(define-pmacro (define-h-csmr-reg csmr-entry csmr-index n csmr-comment)
  (define-hardware
    (name (.sym "h-" (.downcase csmr-entry) "-" (.downcase csmr-index)))
    (comment csmr-comment)
    (attrs VIRTUAL (MACH OPENPXb-MACHS))
    (type register UWI)
    (get ()       (reg UWI h-csmr (csmr-address csmr-entry csmr-index)))
    (set (newval) (set (reg UWI h-csmr (csmr-address csmr-entry csmr-index)) newval))
    )
  )
(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-csmr-reg args)) (csmr-reg-info))))

(define-pmacro (csmr-field-info)
   ;
   ; <entry> <index> <field> <field-msb> <field-lsb> <comment>
   ;  |        |         |        |           |          |
   ;  |   ------  --------        |           |          |
   ;  |   |       |     -----------           |          |
   ;  |   |       |     |  --------------------          |
   ;  |   |       |     |  |        ----------------------
   ;  |   |       |     |  |        |
  (( CR CPUID    VER    8  0  "Version Data")
   ( CR CPUID    REV    14 9  "Revision Data")
   ( CR CPUID    PXB32  15 15 "OPNEPXb-32bit Instructions Support")
   ( CR CPUID    PXB64  16 16 "OPNEPXb-64bit Instructions Support")
   ( CR CPUID    FPX32  17 17 "FPX-32bit Instructions Support")
   ( CR CPUID    FPX64  18 18 "FPX-64bit Instructions Support")
   ( CR CPUID    VX64   19 19 "VX-64bit Instructions Support")
   
   ( CR EX       IE     0  0  "Interrupt exception Enable")
   ( CR EX       OE     1  1  "ALU Overflow exception Enable")
   ( CR EX       EF     2  2  "Exception flag")
   
   ( CR DPR      ICP    0  0  "I-Cache present")
   ( CR DPR      DCP    1  1  "D-Cache present")
   ( CR DPR      IMMUP  2  2  "I-MMU present")
   ( CR DPR      DMMUP  3  3  "D-MMU present")
   ( CR DPR      TMRUP  4  4  "Timer Unit present")
   ( CR DPR      PICU   5  5  "PIC Unit present")
   ( CR DPR      DGBUP  6  6  "Debugging Unit present")
   ( CR DPR      FPUP   7  7  "Float Point Unit present")
   ( CR DPR      PMUP   8  8  "Power Management Unit present")
   ( CR DPR      PMCUP  9  9  "Performance Counter Unit present")
   
   ( CR FPUC     RM     1  0  "Rounding Mode")
   
   (CSR PSR      CF     0  0  "Condition Flag")
   (CSR PSR      CY     1  1  "Carry (Unsigned overflow)")
   (CSR PSR      OV     2  2  "Overflow")
   
   (CSR MSR      RM     0  0  "In Root mode")
   )
  )

(define-normal-enum
  csmr-field-msbs
  "CSMR field msb positions"
  ()
  CSMR-FIELD-MSB-
  (.map (.pmacro (args)
                 (.apply (.pmacro (entry index field msb lsb comment)
                                  ((.sym entry "-" index "-" field) msb)
                                  )
                         args
                         )
                 )
        (csmr-field-info)
        )
  )

(define-normal-enum
  csmr-field-lsbs
  "CSMR field lsb positions"
  ()
  CSMR-FIELD-SIZE-
  (.map (.pmacro (args)
                 (.apply (.pmacro (entry index field msb lsb comment)
                                  ((.sym entry "-" index "-" field) lsb)
                                  )
                         args
                         )
                 )
        (csmr-field-info)
        )
  )

(define-normal-enum
  csmr-field-masks
  "CSMR field masks"
  ()
  CSMR-FIELD-MASK-
  (.map (.pmacro (args)
                 (.apply (.pmacro (entry index field msb lsb comment)
                                  (.splice (.str entry "-" index "-" field) (.sll (.inv (.sll (.inv 0) (.add (.sub msb lsb) 1))) lsb))
                                  )
                         args
                         )
                 )
        (csmr-field-info)
        )
  )


(define-pmacro (define-h-csmr-field csmr-entry csmr-index csmr-field csmr-field-msb csmr-field-lsb csmr-field-comment)
  (.let ((csmr-field-name (.sym "h-" (.downcase csmr-entry) "-" (.downcase csmr-index) "-" (.downcase csmr-field)))
         )
        (begin
          (define-hardware
            (name csmr-field-name)
            (comment csmr-field-comment)
            (attrs VIRTUAL (MACH OPENPXb-MACHS))
            (type register UWI)
            (get ()      (c-call UWI  "@cpu@_h_csmr_field_get_raw" (csmr-address csmr-entry csmr-index) csmr-field-msb csmr-field-lsb))
            (set (value) (c-call VOID "@cpu@_h-csmr_field_set_raw" (csmr-address csmr-entry csmr-index) csmr-field-msb csmr-field-lsb value))
            )
          )
        )
  )

(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-csmr-field args)) (csmr-field-info))) )


;***************************************************************************

;
; Instructions
;

(define-attr
  (for insn)
  (type boolean)
  (name FORCED-CTI)
  (comment "instruction may forcefully transfer control (e.g., rfe)")
  )

;***************************************************************************
; keep-mach basis (Basis instruction group)
;***************************************************************************

(if (keep-mach? (OPENPXb-MACHS) )
  (begin

    ; Hardware for immediate operands
    (dnh h-simm16   "16-bit signed immediate"   () (immediate (INT 16)) () () ())
    (dnh h-uimm16   "16-bit unsigned immediate" ()  (immediate (UINT 16)) () () ())

    
    ;***************************************************************************
    ; Instruction fields.
    ;***************************************************************************
    (dnf f-opcode   "<opcode>"  () 5 6)
    (dnf f-rd       "<rd>"      () 10 5)
    (dnf f-rs1      "<rs1>"     () 15 5)
    (dnf f-rs2      "<rs2>"     () 26 5)
    (dnf f-alu-opc  "<alu-opc>" () 21 6)
    (dnf f-sub-alu-opc "<sub-alu-opc>" () 10 5)
    (dnf f-uimm16   "<uimm16>"  () 31 16)
    (df  f-simm16   "<simm16>"  (SIGN-OPT) 31 16 INT #f #f)

    ; <address> PC relative, 26-bit
    (df f-rel26
        "rel26"
        (PCREL-ADDR)
        31
        26
        INT
        ((value pc) (sra SI (sub IAI value pc) (const 2)))
        ((value pc) (add IAI (sll IAI value (const 2)) pc))
        )
      
    ; reserved
    (dnf f-res-rd       "<res>-<rd>"        (RESERVED) 10 5)
    (dnf f-res-rs1      "<res>-<rs1>"       (RESERVED) 15 5)
    (dnf f-res-rs2      "<res>-<rs2>"       (RESERVED) 26 5)
    (dnf f-res-imm16    "res-imm16"         (RESERVED) 31 16)
    (dnf f-res-31-5     "<res>-31-5"        (RESERVED) 31 5)

    
    ;***************************************************************************
    ; Enums.
    ;***************************************************************************

    ; <opcode> [5..0]
    (define-normal-insn-enum insn-opcode "<opcode> insn opcode enums" ()
      OPC_
      f-opcode
      (
       ("NOP"               #x00)
       ; insn groups (offset = 1)
       ("GRPSI"             #x01)
       ("GRPMI"             #x02)
       ("GRPL"              #x03)
       ("GRPT"              #x04)
       ("GRPJ"              #x05)
       ("GRPF"              #x06)
       
       ; imm. type ALU insn (offset = a)
       ("ADD.I"             #x0a)
       ("AND.I"             #x0b)
       ("OR.I"              #x0c)
       ("XOR.I"             #x0d)
       ("LSL.I"             #x0e)
       ("LSR.I"             #x0f)
       ("ASR.I"             #x10)
       ("CMP.I"             #x11)
       ("MOVH"              #x12)
       ("RDSMR"             #x13)
       ("WRSMR"             #x14)
       ("JMPS"              #x15)
       ("JMPSL"             #x16)
       ("BNCT"              #x17)
       ("BNCF"              #x18)
       ("LDB"               #x19)
       ("LDB.U"             #x1a)
       ("LDH"               #x1b)
       ("LDH.U"             #x1c)
       ("LDW"               #x1d)
       ("LDW.U"             #x1e)
       ("LDWA"              #x1f)
       ("STB"               #x20)
       ("STH"               #x21)
       ("STW"               #x22)
       ("STWA"              #x23)
       ("SYSCALL"           #x24)
       ("TRAP"              #x25)
       ("MSYNC"             #x26)
       ("RESUME"            #x27)
     )
    )

    ; <alu-opc> [26..21] GRPSI <General Integer Operation>
    (define-normal-insn-enum insn-opcode-grpsi "<alu-opc> insn opcode enums" () 
      OPC_GRPSI_
      f-alu-opc
        (
         ("ADD"             #x00)
         ("SUB"             #x01)
         ("CMPEQ"           #x02)
         ("CMPGT"           #x03)
         ("CMPGT.U"         #x04)
        )
    )
    
    ; <alu-opc> [26..21] GRPMI <General Integer Operation>
    (define-normal-insn-enum insn-opcode-grpmi "<alu-opc> insn opcode enums" () 
      OPC_GRPMI_
      f-alu-opc
        (
         ("MUL"             #x00)
         ("MUL.U"           #x01)
         ("DIV"             #x02)
         ("DIV.U"           #x03)
        )
    )
    
    ; <alu-opc> [26..21] GRP-L <General Logical Operation>
    (define-normal-insn-enum insn-opcode-grpl "<alu-opc> insn opcode enums" () 
      OPC_GRPL_
      f-alu-opc
        (
         ("AND"             #x00)
         ("OR"              #x01)
         ("XOR"             #x02)
         ("LSL"             #x03)
         ("LSR"             #x04)
         ("ASR"             #x05)
        )
    )

    ; <sub-alu-opc> [10..5] sub-alu-opc
    (define-normal-insn-enum insn-opcode-sub-alu-opc "<sub-alu-opc> insn opcode enums" () 
      OPC_SUB_ALU_
      f-sub-alu-opc
        (
         ("CMPEQ.I"         #x02) ; for each cmp instruction should keep the same opcode with f-alu-opc
         ("CMPGT.I"         #x03)
         ("CMPGT.UI"        #x04)
         ("CMPLT.I"         #x05)
         ("CMPLT.UI"        #x06)
        )
    )

    ; <alu-opc> [26..21] GRPT <Transfer>
    (define-normal-insn-enum insn-opcode-grpt "<alu-opc> insn opcode enums" () 
      OPC_GRPT_
      f-alu-opc
        (
         ("MOV"             #x00)
         ("CMOV"            #x01)
        )
    )

    ; <alu-opc> [26..21] GRPJ <jump>
    (define-normal-insn-enum insn-opcode-grpj "<alu-opc> insn opcode enums" () 
      OPC_GRPJ_
      f-alu-opc
      (
       ("JMP"               #x00)
       ("JMPL"              #x01)
      )
    )


    
    ;***************************************************************************
    ; Instruction operands.
    ;***************************************************************************

    ; operands for insns
    (dnop rs1   "source register #1"        ()          h-gpr               f-rs1)
    (dnop rs2   "source register #2"        ()          h-gpr               f-rs2)
    (dnop rd    "destination register"      ()          h-gpr               f-rd)

    (define-operand
      (name rel26)
      (comment "pc-rel 26 bit address")
      (attrs)
      (type h-iaddr)
      (index f-rel26)
      (handlers (parse "rel26"))
      )

    (define-operand
      (name simm16)
      (comment "16-bit signed immediate")
      (attrs SIGN-OPT)
      (type h-simm16)
      (index f-simm16)
      (handlers (parse "simm16"))
      )

    (define-operand
      (name uimm16)
      (comment "16-bit unsigned immediate")
      (attrs)
      (type h-uimm16)
      (index f-uimm16)
      (handlers (parse "uimm16"))
      )
      
    ; operands of CSMR (only for semantics description)
    (dnop csr-psr-cf "PSR condition flag bit" (SEM-ONLY) h-csr-psr-cf      f-nil)
    (dnop csr-psr-cy "PSR carry bit"        (SEM-ONLY) h-csr-psr-cy      f-nil)
    (dnop csr-psr-ov "PSR overflow bit"     (SEM-ONLY) h-csr-psr-ov      f-nil)
    (dnop cr-ex-oe "EX overflow exception enable bit" (SEM-ONLY) h-cr-ex-oe f-nil)

    

    (dni nop "nop"
         ()
         "nop"
         (+ OPC_NOP (f-res-rd 0) (f-res-rs1 0) (f-res-imm16 0))
         (nop)
         ()
    )

    
    ;***************************************************************************
    ; ALU regs. Instructions
    ;***************************************************************************

    (define-pmacro (si-regs-alu-carry-insn mnemonic)
      (begin
        (dni mnemonic
             (.str mnemonic " reg/reg/reg")
             ()
             (.str mnemonic " $rd,$rs1,$rs2")
             (+ OPC_GRPSI rd rs1 rs2 (.sym OPC_GRPSI_ (.upcase mnemonic)) (f-res-31-5 0) )
             (sequence ()
                       (sequence ()
                                 (set BI csr-psr-cy ((.sym mnemonic "c-cflag") WI rs1 rs2 0))
                                 (set BI csr-psr-ov ((.sym mnemonic "c-oflag") WI rs1 rs2 0))
                                 (set rd (mnemonic WI rs1 rs2))
                                 )
                       (if (andif csr-psr-ov cr-ex-oe)
                           (raise-exception EXCEPT-EOVERFLOW))
                       )
             ()
             )
        )
      )

    (si-regs-alu-carry-insn add)
    (si-regs-alu-carry-insn sub)

    (dni mul "mul reg/reg/reg"
      ()
      ("mul $rd,$rs1,$rs2")
      (+ OPC_GRPMI rd rs1 rs2 OPC_GRPMI_MUL (f-res-31-5 0) )
      (sequence ()
                (sequence ()
                          ; 2's complement overflow
                          (set BI csr-psr-ov (mul-o2flag WI rs1 rs2))
                          ; 1's complement overflow
                          (set BI csr-psr-cy (mul-o1flag WI rs1 rs2))
                          (set rd (mul WI rs1 rs2))
                          )
                (if (andif csr-psr-ov cr-ex-oe)
                    (raise-exception EXCEPT-EOVERFLOW))
                )
      ()
    )

    (dni mul.u "mul.u reg/reg/reg"
      ()
      ("mul.u $rd,$rs1,$rs2")
      (+ OPC_GRPMI rd rs1 rs2 OPC_GRPMI_MUL.U (f-res-31-5 0) )
      (sequence ()
                (sequence ()
                          ; 2's complement overflow
                          (set BI csr-psr-ov 0)
                          ; 1's complement overflow
                          (set BI csr-psr-cy (mul-o1flag UWI rs1 rs2))
                          (set rd (mul UWI rs1 rs2))
                          )
                (if (andif csr-psr-ov cr-ex-oe)
                    (raise-exception EXCEPT-EOVERFLOW))
                )
      ()
    )

    (dni div "div (signed) reg/reg/reg"
      ()
      "div $rd,$rs1,$rs2"
      (+ OPC_GRPMI rd rs1 rs2 OPC_GRPMI_DIV (f-res-31-5 0) )
      (sequence ()
                (if (ne rs2 0)
                    (sequence ()
                              (set BI csr-psr-cy 0)
                              (set WI rd (div WI rs1 rs2))
                              )
                    (set BI csr-psr-cy 1)
                    )
                (set BI csr-psr-ov 0)
                (if (andif csr-psr-cy cr-ex-oe)
                    (raise-exception EXCEPT-EOVERFLOW))
                )
      ()
    )

    (dni div.u "div (unsigned) reg/reg/reg"
      ()
      "div.u $rd,$rs1,$rs2"
      (+ OPC_GRPMI rd rs1 rs2 OPC_GRPMI_DIV.U (f-res-31-5 0) )
      (sequence ()
                (if (ne rs2 0)
                    (sequence ()
                              (set BI csr-psr-cy 0)
                              (set rd (udiv UWI rs1 rs2))
                              )
                    (set BI csr-psr-cy 1)
                    )
                (set BI csr-psr-ov 0)
                (if (andif csr-psr-cy cr-ex-oe)
                    (raise-exception EXCEPT-EOVERFLOW))
                )
      ()
    )

    (define-pmacro (l-regs-alu-insn mnemonic)
      (begin
         (dni mnemonic
              (.str mnemonic " reg/reg/reg")
              ()
              (.str mnemonic " $rd,$rs1,$rs2")
              (+ OPC_GRPL rd rs1 rs2 (.sym OPC_GRPL_ (.upcase mnemonic)) (f-res-31-5 0) )
              (set rd (mnemonic rs1 rs2))
              ()
         )
      )
    )

    (l-regs-alu-insn and)
    (l-regs-alu-insn or)
    (l-regs-alu-insn xor)

    (define-pmacro (l-regs-shift-insn mnemonic binop)
      (begin
         (dni mnemonic
              (.str mnemonic " reg/reg/reg")
              ()
              (.str mnemonic " $rd,$rs1,$rs2")
              (+ OPC_GRPL rd rs1 rs2 (.sym OPC_GRPL_ (.upcase mnemonic)) (f-res-31-5 0) )
              (set UWI rd (binop rs1 rs2))
              ()
         )
       )
    )

    (l-regs-shift-insn lsl sll)
    (l-regs-shift-insn lsr srl)
    (l-regs-shift-insn asr sra)

    
    (dni mov
      (.str "mov reg/reg")
      ()
      (.str "mov $rd,$rs1")
      (+ OPC_GRPT rd rs1 (f-res-rs2 0) OPC_GRPT_MOV (f-res-31-5 0) )
      (set rd rs1)
      ()
    )

    (dni cmov
      (.str "cmov reg/reg/reg")
      ()
      (.str "cmov $rd,$rs1,$rs2")
      (+ OPC_GRPT rd rs1 rs2 OPC_GRPT_CMOV (f-res-31-5 0) )
      (sequence ()
        (if csr-psr-cf (set rd rs1) (set rd rs2))
       )
      ()
    )


    
    ;***************************************************************************
    ; ALU imm. Instructions
    ;***************************************************************************

    (define-pmacro (simm-alu-carry-insn mnemonic binop)
      (begin
        (dni (.sym mnemonic ".i")
             (.str mnemonic " reg/reg/simm16")
             ()
             (.str mnemonic " $rd,$rs1,$simm16")
             (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 simm16)
             (sequence ()
                       (sequence ()
                                 (set BI csr-psr-cy ((.sym binop "c-cflag") WI rs1 (ext WI simm16) 0))
                                 (set BI csr-psr-ov ((.sym binop "c-oflag") WI rs1 (ext WI simm16) 0))
                                 (set rd (binop WI rs1 (ext WI simm16)))
                                 )
                       (if (andif csr-psr-ov cr-ex-oe)
                           (raise-exception EXCEPT-EOVERFLOW))
                       )
             ()
             )
        )
      )

    (simm-alu-carry-insn add add)

    (define-pmacro (uimm-alu-insn  mnemonic binop)
        (begin
          (dni (.sym mnemonic ".i")
               (.str mnemonic " reg/reg/uimm16")
               ()
               (.str mnemonic " $rd,$rs1,$uimm16")
               (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 uimm16)
               (set rd (binop rs1 (zext UWI uimm16)))
               ()
         )
        )
      )

    (define-pmacro (simm-alu-insn  mnemonic binop)
        (begin
          (dni (.sym mnemonic ".i")
              (.str mnemonic " reg/reg/simm16")
              ()
              (.str mnemonic " $rd,$rs1,$simm16")
              (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 simm16)
              (set rd (binop rs1 (ext WI simm16)))
              ()
         )
        )
      )

    (uimm-alu-insn and and)
    (uimm-alu-insn or or)
    (simm-alu-insn xor xor)

    (define-pmacro (uimm-shift-insn mnemonic binop)
        (dni (.sym mnemonic ".i")
              (.str mnemonic " reg/reg/uimm16")
              ()
              (.str mnemonic " $rd,$rs1,${uimm16}")
              (+ (.sym OPC_ (.upcase mnemonic) ".I" ) rd rs1 uimm16)
              (set rd (binop rs1 uimm16))
              ()
         )
     )
     
    (uimm-shift-insn lsl sll)
    (uimm-shift-insn lsr srl)
    (uimm-shift-insn asr sra)

    
    ;***************************************************************************
    ; Comparision regs. && imm. Instructions
    ;***************************************************************************

    (define-pmacro (cmp-eqlt-insn op)
      (begin
         (dni (.sym "cmp" op)
              (.str "cmp" op " reg/reg")
              ()
              (.str "cmp" op " $rs1,$rs2")
              (+ OPC_GRPSI (f-res-rd 0) rs1 rs2 (.sym OPC_GRPSI_ (.upcase (.sym "cmp" op))) (f-res-31-5 0) )
              (set csr-psr-cf (op WI rs1 rs2))
              ()
         )
         (dni (.sym "cmp" op ".i")
              (.str "cmp" op " reg/simm16")
              ()
              (.str "cmp" op " $rs1,$simm16")
              (+ OPC_CMP.I (.sym OPC_SUB_ALU_ (.upcase (.sym "cmp" op ".i"))) rs1 simm16)
              (set csr-psr-cf (op WI rs1 (ext WI simm16)))
              ()
         )
       )
    )

    (cmp-eqlt-insn eq)

    (define-pmacro (cmp-insn-i-u op)
      (begin
         (dni (.sym "cmp" op ".i")
              (.str "cmp" op " reg/simm16")
              ()
              (.str "cmp" op " $rs1,$simm16")
              (+ OPC_CMP.I (.sym OPC_SUB_ALU_ (.upcase (.sym "cmp" op ".i"))) rs1 simm16)
              (set csr-psr-cf (op WI rs1 (ext WI simm16)))
              ()
              )
         ; immediate is sign extended even for unsigned compare
         (dni (.sym "cmp" op ".ui")
              (.str "cmp" op ".u reg/simm16")
              ()
              (.str "cmp" op ".u $rs1,$simm16")
              (+ OPC_CMP.I (.sym OPC_SUB_ALU_ (.upcase (.sym "cmp" op ".ui"))) rs1 simm16)
              (set csr-psr-cf ((.sym op "u") WI rs1 (ext WI simm16)))
              ()
              )
      )
    )

    ; signed
    (dni (.sym "cmpgt")
        (.str "cmpgt reg/reg")
        ()
        (.str "cmpgt $rs1,$rs2")
        (+ OPC_GRPSI (f-res-rd 0) rs1 rs2 (.sym OPC_GRPSI_CMPGT) (f-res-31-5 0) )
        (set csr-psr-cf (gt WI rs1 rs2))
        ()
        )
    ; unsigned
    (dni (.sym "cmpgt.u")
        (.str "cmpgt.u reg/reg")
        ()
        (.str "cmpgt.u $rs1,$rs2")
        (+ OPC_GRPSI (f-res-rd 0) rs1 rs2 (.sym OPC_GRPSI_CMPGT.U) (f-res-31-5 0) )
        (set csr-psr-cf (gtu WI rs1 rs2))
        ()
        )
    (cmp-insn-i-u gt)

    ; signed
    (dni (.sym "cmplt")
        (.str "cmplt reg/reg")
        ()
        (.str "cmplt $rs2,$rs1")
        (+ OPC_GRPSI (f-res-rd 0) rs1 rs2 (.sym OPC_GRPSI_CMPGT) (f-res-31-5 0) )
        (set csr-psr-cf (lt WI rs1 rs2))
        ()
        )
    ; unsigned
    (dni (.sym "cmplt.u")
        (.str "cmplt.u reg/reg")
        ()
        (.str "cmplt.u $rs2,$rs1")
        (+ OPC_GRPSI (f-res-rd 0) rs1 rs2 (.sym OPC_GRPSI_CMPGT.U) (f-res-31-5 0) )
        (set csr-psr-cf (ltu WI rs1 rs2))
        ()
        )
    (cmp-insn-i-u lt)


    
    ;***************************************************************************
    ; Transmission imm. Instructions
    ;***************************************************************************

    (dni mov.i
      (.str "mov reg/uimm16")
      ()
      (.str "mov $rd,$uimm16")
      (+ OPC_OR.I rd (f-res-rs1 0) uimm16)
      (set rd rs1)
      ()
    )

    (dni movh "movh reg/uimm16"
         ()
         "mov hi($rd),$uimm16"
         (+ OPC_MOVH rd (f-res-rs1 0) uimm16)
         (set UWI rd (sll UWI (zext UWI uimm16) (const 16)))
         ()
    )

    (dni rdsmr "rdsmr"
         ()
         "rdsmr $rd,$rs1,${uimm16}"
         (+ OPC_RDSMR rd rs1 uimm16)
         (set UWI rd (c-call UWI "@cpu@_rdsmr" (or rs1 (zext UWI uimm16))))
         ()
    )

    (dni wrsmr "wrsmr"
         ()
         "wrsmr $rd,$rs1,${uimm16}"
         (+ OPC_WRSMR rd rs1 uimm16)
         (c-call VOID "@cpu@_wrsmr" (or rd (zext WI uimm16)) rs1)
         ()
    )

    
    ;***************************************************************************
    ; Branch regs. Instructions
    ;***************************************************************************

    (define-pmacro (cti-link-return)
      (set IAI (reg h-gpr 29) (add pc 8))
      )
    (define-pmacro (cti-transfer-control condition target)
      (sequence ()
        (if condition
            (set IAI pc target)
            )
        )
      )

    (define-pmacro
      (define-cti
        cti-name
        cti-comment
        cti-attrs
        cti-syntax
        cti-format
        cti-semantics)
      (begin
        (dni
          cti-name
          cti-comment
          cti-attrs
          cti-syntax
          cti-format
          (cti-semantics)
          ()
          )
        )
      )
      
      
    (define-cti
      jmp
      "jmp reg (absolute)"
      (!COND-CTI UNCOND-CTI)
      "jmp $rs1"
      (+ OPC_GRPJ (f-res-rd 0) rs1 (f-res-rs2 0) OPC_GRPJ_JMP (f-res-31-5 0) )
      (.pmacro ()
               (cti-transfer-control 1 rs1)
               )
      )

    (define-cti
      jmpl
      "jmp reg and link (absolute)"
      (!COND-CTI UNCOND-CTI)
      "jmpl $rs1"
      (+ OPC_GRPJ (f-res-rd 0) rs1 (f-res-rs2 0) OPC_GRPJ_JMPL (f-res-31-5 0) )
      (.pmacro ()
               (sequence ()
                         (cti-link-return)
                         (cti-transfer-control 1 rs1)
                         )
               )
      )

    
    ;***************************************************************************
    ; Branch addr. Instructions
    ;***************************************************************************

    (define-cti
      jmps
      "jmp segment (pc-relative rel26)"
      (!COND-CTI UNCOND-CTI)
      "jmps ${rel26}"
      (+ OPC_JMPS rel26)
      (.pmacro ()
               (cti-transfer-control 1 rel26)
               )
       )
      
    (define-cti
      jmpsl
      "jmp segment and link (pc-relative rel26)"
      (!COND-CTI UNCOND-CTI)
      "jmpsl ${rel26}"
      (+ OPC_JMPSL rel26)
      (.pmacro ()
               (sequence ()
                         (cti-link-return)
                         (cti-transfer-control 1 rel26)
                         )
               )
      )

    (define-cti
      bnct
      "branch if condition bit is TRUE (pc relative addressing)"
      (COND-CTI !UNCOND-CTI)
      "bnct ${rel26}"
      (+ OPC_BNCT rel26)
      (.pmacro ()
               (cti-transfer-control csr-psr-cf rel26)
               )
      )

    (define-cti
      bncf
      "branch if condition bit is FALSE (pc relative addressing)"
      (COND-CTI !UNCOND-CTI)
      "bncf ${rel26}"
      (+ OPC_BNCF rel26)
      (.pmacro ()
               (cti-transfer-control (not csr-psr-cf) rel26)
               )
      )

    
    ;***************************************************************************
    ; Load/Store imm. Instructions
    ;***************************************************************************

    (define-pmacro (load-store-addr base offset size)
      (c-call AI "@cpu@_get_load_store_addr" base (ext SI offset) size))

    (dsh h-atomic-c     "atomic condition"          () (register BI))
    (dsh h-atomic-addr  "previous store address"    () (register SI))
    (dnop atomic-c      "atomic condition"          (SEM-ONLY) h-atomic-c       f-nil)
    (dnop atomic-addr   "previous store address"    (SEM-ONLY) h-atomic-addr    f-nil)

    (dni ldb "ldb reg/simm16(reg) (signed)"
         ()
         "ld $rd,@byte,${simm16}($rs1)"
         (+ OPC_LDB rd rs1 simm16)
         (set WI rd (ext WI (mem QI (load-store-addr rs1 simm16 1))))
         ()
    )

    (dni ldb.u "ldb.u reg/simm16(reg) (signed)"
         ()
         "ld.u $rd,@byte,${simm16}($rs1)"
         (+ OPC_LDB.U rd rs1 simm16)
         (set UWI rd (zext UWI (mem UQI (load-store-addr rs1 simm16 1))))
         ()
    )

    (dni ldh "ldh reg/simm16(reg) (signed)"
         ()
         "ld $rd,@hword,${simm16}($rs1)"
         (+ OPC_LDH rd rs1 simm16)
         (set WI rd (ext WI (mem HI (load-store-addr rs1 simm16 2))))
         ()
    )

    (dni ldh.u "ldh.u reg/simm16(reg) (signed)"
         ()
         "ld.u $rd,@hword,${simm16}($rs1)"
         (+ OPC_LDH.U rd rs1 simm16)
         (set UWI rd (zext UWI (mem UHI (load-store-addr rs1 simm16 2))))
         ()
    )

    (dni ldw "ldw reg/simm16(reg) (signed)"
         ()
         "ld $rd,@word,${simm16}($rs1)"
         (+ OPC_LDW rd rs1 simm16)
         (set WI rd (ext WI (mem SI (load-store-addr rs1 simm16 4))))
         ()
    )

    (dni ldw.u "ldw.u reg/simm16(reg) (signed)"
         ()
         "ld.u $rd,@word,${simm16}($rs1)"
         (+ OPC_LDW.U rd rs1 simm16)
         (set UWI rd (zext UWI (mem USI (load-store-addr rs1 simm16 4))))
         ()
    )

    (dni ldwa "ldwa reg/simm16(reg)"
         ()
         "ldwa $rd,@word,${simm16}($rs1)"
         (+ OPC_LDWA rd rs1 simm16)
         (sequence ()
             (set UWI rd (zext UWI (mem USI (load-store-addr rs1 simm16 4))))
             (set atomic-c (const 1))
             (set atomic-addr (load-store-addr rs1 simm16 4))
           )
         ()
    )

    (define-pmacro (store-insn mnemonic tp opc-op mode size)
      (begin
         (dni mnemonic
              (.str mnemonic " simm16(reg)/reg")
              ()
              (.str "st @" tp ",${simm16}($rd),$rs1")
              (+ opc-op rd rs1 simm16)
              (sequence ((SI addr))
                (set addr (load-store-addr rd simm16 size))
                (set mode (mem mode addr) (trunc mode rs1))
                (if (eq (and addr #xffffffc) atomic-addr)
                    (set atomic-c (const 0))
                 )
               )
              ()
         )
       )
    )

    (store-insn stb "byte"  OPC_STB UQI 1)
    (store-insn sth "hword" OPC_STH UHI 2)
    (store-insn stw "word"  OPC_STW USI 4)

    (dni stwa "stwa simm16(reg)/reg"
         ()
         "stwa @word,${simm16}($rd),$rs1"
         (+ OPC_STWA rd rs1 simm16)
         (sequence ((SI addr))
               (set addr (load-store-addr rd simm16 4))
               (set csr-psr-cf (and atomic-c (eq addr atomic-addr)))
               (if csr-psr-cf
                (set USI (mem USI addr) (trunc USI rs1))
               )
               (set atomic-c (const 0))
               )
         ()
    )

    
    ;***************************************************************************
    ; System imm. Instructions
    ;***************************************************************************

    (dni syscall "syscall (exception)"
         ()
         "syscall ${uimm16}"
         (+ OPC_SYSCALL (f-res-rd 0) (f-res-rs1 0) uimm16)
         ; Do exception entry handling in C function, PC set based on SR state
         (raise-exception EXCEPT-ESYSCALL)
         ()
    )

    (dni trap "trap (exception)"
         ()
         "trap ${uimm16}"
         (+ OPC_TRAP (f-res-rd 0) (f-res-rs1 0) uimm16)
         ; Do exception entry handling in C function, PC set based on SR state
         (raise-exception EXCEPT-ETRAP)
         ()
    )


    (dni msync "memory queue sync"
         ()
         "msync"
         (+ OPC_MSYNC (f-res-rd 0) (f-res-rs1 0) (f-res-imm16 0))
         (nop)
         ()
    )

    (dni resume "resume from exception"
         ()
         "resume"
         (+ OPC_RESUME (f-res-rd 0) (f-res-rs1 0) (f-res-imm16 0))
         (c-call VOID "@cpu@_resume")
         ()
    )


  ) ; begin
) ; keep-mach? (OPENPXb-MACHS)

;***************************************************************************
; keep-mach FPX (Floating pointer ext)
;***************************************************************************

(if (keep-mach? (OPENPXf-MACHS) )
  ; (include "openpx64k-fpx.cpu")
  (begin

    ; <alu-opc> [26..21] EXGRP #1
    (define-normal-insn-enum insn-opcode-float-regreg "floating point reg/reg insn opcode enums" ()
      OPC_GRPF_
      f-alu-opc
      (("FADD.S"    #x00)
       ("FSUB.S"    #x01)
       ("FMUL.S"    #x02)
       ("FDIV.S"    #x03)
       ("FITF.S"    #x04)
       ("FFTI.S"    #x05)
       ("FREM.S"    #x06)
       ("FMADD.S"   #x07)
       ("FCMPEQ.S"  #x08)
       ("FCMPGT.S"  #x09)
       ("FADD.D"    #x0a)
       ("FSUB.D"    #x0b)
       ("FMUL.D"    #x0c)
       ("FDIV.D"    #x0d)
       ("FITF.D"    #x0e)
       ("FFTI.D"    #x0f)
       ("FREM.D"    #x10)
       ("FMADD.D"   #x11)
       ("FCMPEQ.D"  #x12)
       ("FCMPGT.D"  #x13)
       )
      )

    ; operands
    (dnop cr-fpuc-rm "round mode" (SEM-ONLY) h-cr-fpuc-rm f-nil)

    (dnop frdS  "destination register (single floating point mode)" () h-frs f-rd)
    (dnop frs1S "source register A (single floating point mode)"    () h-frs f-rs1)
    (dnop frs2S "source register B (single floating point mode)"    () h-frs f-rs2)

    (dnop frdD  "destination register (double floating point mode)" ((MACH OPENPXf64-MACHS)) h-frd f-rd)
    (dnop frs1D "source register A (double floating point mode)"    ((MACH OPENPXf64-MACHS)) h-frd f-rs1)
    (dnop frs2D "source register B (double floating point mode)"    ((MACH OPENPXf64-MACHS)) h-frd f-rs2)


    (define-pmacro (float-regs-insn mnemonic fop)
      (begin
        (dni (.sym mnemonic -s)
             (.str mnemonic ".s reg/reg/reg")
             ()
             (.str mnemonic ".s $frdS,$frs1S,$frs2S")
             (+ OPC_GRPF frdS frs1S frs2S (.sym OPC_GRPF_ (.upcase mnemonic) ".S" ) (f-res-31-5 0) )
             (set SF frdS (fop SF frs1S frs2S))
             ()
             )
        (dni (.sym mnemonic -d)
             (.str mnemonic ".d reg/reg/reg")
             ((MACH OPENPXf64-MACHS))
             (.str mnemonic ".d $frdD,$frs1D,$frs2D")
             (+ OPC_GRPF frdD frs1D frs2D (.sym OPC_GRPF_ (.upcase mnemonic) ".D" ) (f-res-31-5 0) )
             (set DF frdD (fop DF frs1D frs2D))
             ()
             )
        )
      )

    (float-regs-insn fadd add)
    (float-regs-insn fsub sub)
    (float-regs-insn fmul mul)
    (float-regs-insn fdiv div)

    (dni frem-s
         "frem.s reg/reg/reg"
         ()
         "frem.s $frdS,$frs1S,$frs2S"
         (+ OPC_GRPF frdS frs1S frs2S OPC_GRPF_FREM.S (f-res-31-5 0) )
         (set SF frdS (rem SF frs1S frs2S))
         ()
         )
    (dni frem-d
         "frem.d reg/reg/reg"
         ((MACH OPENPXf64-MACHS))
         "frem.d $frdD,$frs1D,$frs2D"
         (+ OPC_GRPF frdD frs1D frs2D OPC_GRPF_FREM.D (f-res-31-5 0) )
         (set DF frdD (mod DF frs1D frs2D))
         ()
         )

    (define-pmacro (get-rounding-mode)
      (case INT cr-fpuc-rm
            ((0) 1) ; TIES-TO-EVEN
            ((1) 3) ; TOWARD-ZERO
            ((2) 4) ; TOWARD-POSITIVE
            (else 5) ; TOWARD-NEGATIVE
            )
      )

    (dni fitf-s
         "fitf.s reg/reg"
         ()
         "fitf.s $frdS,$rs1"
         (+ OPC_GRPF frdS rs1 (f-res-rs2 0) OPC_GRPF_FITF.S (f-res-31-5 0) )
         (set SF frdS (float SF (get-rounding-mode) (trunc SI rs1)))
         ()
         )
    (dni fitf-d
         "fitf.d reg/reg"
         ((MACH OPENPXf64-MACHS))
         "fitf.d $frdD,$rs1"
         (+ OPC_GRPF frdD rs1 (f-res-rs2 0) OPC_GRPF_FITF.D (f-res-31-5 0) )
         (set DF frdD (float DF (get-rounding-mode) rs1))
         ()
         )

    (dni ffti-s
         "ffti.s reg/reg"
         ()
         "ffti.s $rd,$frs1S"
         (+ OPC_GRPF rd frs1S (f-res-rs2 0) OPC_GRPF_FFTI.S (f-res-31-5 0) )
         (set WI rd (ext WI (fix SI (get-rounding-mode) frs1S)))
         ()
         )

    (dni ffti-d
         "ffti.d reg/reg"
         ((MACH OPENPXf64-MACHS))
         "ffti.d $rd,$frs1D"
         (+ OPC_GRPF rd frs1D (f-res-rs2 0) OPC_GRPF_FFTI.D (f-res-31-5 0) )
         (set DI rd (fix DI (get-rounding-mode) frs1D))
         ()
         )

    (define-pmacro (float-cmp-insn mnemonic)
      (begin
        (dni (.sym fcmp mnemonic -s)
             (.str "fcmp" mnemonic ".s reg/reg")
             ()
             (.str "fcmp" mnemonic ".s $frs1S,$frs2S")
             (+ OPC_GRPF (f-res-rd 0) frs1S frs2S (.sym OPC_GRPF_FCMP (.upcase mnemonic) ".S") (f-res-31-5 0) )
             (set BI csr-psr-cf (mnemonic SF frs1S frs2S))
             ()
             )
        (dni (.sym fcmp mnemonic -d)
             (.str "fcmp" mnemonic ".d reg/reg")
             ((MACH OPENPXf64-MACHS))
             (.str "fcmp" mnemonic ".d $frs1D,$frs2D")
             (+ OPC_GRPF (f-res-rd 0) frs1D frs2D (.sym OPC_GRPF_FCMP (.upcase mnemonic) ".D") (f-res-31-5 0) )
             (set BI csr-psr-cf (mnemonic DF frs1D frs2D))
             ()
             )
        )
      )

    (float-cmp-insn eq)
    (float-cmp-insn gt)

    (dni fmadd-s
         "fmadd.s reg/reg/reg"
         ()
         "fmadd.s $frdS,$frs1S,$frs2S"
         (+ OPC_GRPF frdS frs1S frs2S OPC_GRPF_FMADD.S (f-res-31-5 0) )
         (set SF frdS (add SF (mul SF frs1S frs2S) frdS))
         ()
         )
    (dni fmadd-d
         "fmadd.d reg/reg/reg"
         ((MACH OPENPXf64-MACHS))
         "fmadd.d $frdD,$frs1D,$frs2D"
         (+ OPC_GRPF frdD frs1D frs2D OPC_GRPF_FMADD.D (f-res-31-5 0) )
         (set DF frdD (add DF (mul DF frs1D frs2D) frdD))
         ()
         )

  ) ; begin
) ; keep-mach? (OPENPXf-MACHS)

